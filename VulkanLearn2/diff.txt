commit 0647ce8d6eae14b5cb0a9a474538b4511f4fa583
Author: vailoneluon <djtmegemini10102004@gmail.com>
Date:   Tue Nov 18 06:54:42 2025 +0700

    Thêm Material thành công.

diff --git a/VulkanLearn2/Core/VulkanTypes.h b/VulkanLearn2/Core/VulkanTypes.h
index c765adf..16be55a 100644
--- a/VulkanLearn2/Core/VulkanTypes.h
+++ b/VulkanLearn2/Core/VulkanTypes.h
@@ -49,5 +49,5 @@ struct UniformBufferObject
 struct PushConstantData
 {
 	alignas(16) glm::mat4 model;
-	alignas(16) uint32_t textureId;
+	alignas(16) uint32_t materialIndex;
 };
diff --git a/VulkanLearn2/Renderer/GeometryPass.cpp b/VulkanLearn2/Renderer/GeometryPass.cpp
index 904058f..d2a4a85 100644
--- a/VulkanLearn2/Renderer/GeometryPass.cpp
+++ b/VulkanLearn2/Renderer/GeometryPass.cpp
@@ -10,10 +10,13 @@
 #include "Scene/MeshManager.h"
 #include "Scene/RenderObject.h"
 #include "Core/VulkanImage.h"
+#include "Scene\MaterialManager.h"
+
 
 GeometryPass::GeometryPass(const GeometryPassCreateInfo& geometryInfo) :
 	m_TextureDescriptors(geometryInfo.textureManager->getDescriptor()),
 	m_MeshManager(geometryInfo.meshManager),
+	m_MaterialManager(geometryInfo.materialManager),
 	m_ColorImages(geometryInfo.colorImages),
 	m_DepthStencilImages(geometryInfo.depthStencilImages),
 	m_OutputImage(geometryInfo.outputImage),
@@ -161,6 +164,9 @@ void GeometryPass::CreateDescriptor(const std::vector<VulkanBuffer*>& uniformBuf
 		m_UboDescriptors[i] = new VulkanDescriptor(*m_VulkanHandles, uniformBindings, 1); // Set 1
 		m_Handles.descriptors.push_back(m_UboDescriptors[i]);
 	}
+
+	// Set 2: SBO Chứa thông tin Material
+	m_Handles.descriptors.push_back(m_MaterialManager->GetDescriptor());
 }
 
 /**
@@ -203,6 +209,15 @@ void GeometryPass::BindDescriptors(const VkCommandBuffer* cmdBuffer, uint32_t cu
 		&m_UboDescriptors[currentFrame]->getHandles().descriptorSet,
 		0, nullptr
 	);
+
+	// Bind Set 2: SBO chứa thông tin Material.
+	vkCmdBindDescriptorSets(
+		*cmdBuffer,
+		VK_PIPELINE_BIND_POINT_GRAPHICS, m_Handles.pipeline->getHandles().pipelineLayout,
+		m_MaterialManager->GetDescriptor()->getSetIndex(), 1,
+		&m_MaterialManager->GetDescriptor()->getHandles().descriptorSet,
+		0, nullptr
+	);
 }
 
 /**
@@ -220,7 +235,7 @@ void GeometryPass::DrawSceneObject(VkCommandBuffer cmdBuffer)
 			// Gửi dữ liệu cho từng lần vẽ (per-draw data) như ma trận model và ID texture.
 			// Đây là cách hiệu quả để gửi một lượng nhỏ dữ liệu thay đổi thường xuyên.
 			m_PushConstantData->model = renderObject->GetModelMatrix();
-			m_PushConstantData->textureId = mesh->textureId;
+			m_PushConstantData->materialIndex = mesh->materialIndex;
 
 			vkCmdPushConstants(cmdBuffer, m_Handles.pipeline->getHandles().pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(PushConstantData), m_PushConstantData);
 
diff --git a/VulkanLearn2/Renderer/GeometryPass.h b/VulkanLearn2/Renderer/GeometryPass.h
index 2f992b6..06395a2 100644
--- a/VulkanLearn2/Renderer/GeometryPass.h
+++ b/VulkanLearn2/Renderer/GeometryPass.h
@@ -12,6 +12,7 @@ class VulkanBuffer;
 class TextureManager;
 class MeshManager;
 class RenderObject;
+class MaterialManager;
 
 /**
  * @struct GeometryPassCreateInfo
@@ -27,6 +28,7 @@ struct GeometryPassCreateInfo
 	// --- Dữ liệu Scene ---
 	const TextureManager* textureManager;
 	const MeshManager* meshManager;
+	MaterialManager* materialManager;
 	const std::vector<RenderObject*>* renderObjects;
 	const std::vector<VulkanBuffer*>* uniformBuffers; // UBO chứa ma trận camera.
 
@@ -77,6 +79,7 @@ private:
 
 	// --- Tham chiếu đến các tài nguyên bên ngoài ---
 	const MeshManager* m_MeshManager;
+	MaterialManager* m_MaterialManager;
 	const VulkanHandles* m_VulkanHandles;
 	PushConstantData* m_PushConstantData;
 	const std::vector<RenderObject*>* m_RenderObjects;
diff --git a/VulkanLearn2/Resources/Textures/texture_pbr_v128.png b/VulkanLearn2/Resources/Textures/texture_pbr_v128.png
new file mode 100644
index 0000000..d895e63
Binary files /dev/null and b/VulkanLearn2/Resources/Textures/texture_pbr_v128.png differ
diff --git a/VulkanLearn2/Resources/girl.assbin b/VulkanLearn2/Resources/girl.assbin
new file mode 100644
index 0000000..1b00415
Binary files /dev/null and b/VulkanLearn2/Resources/girl.assbin differ
diff --git a/VulkanLearn2/Scene/MaterialManager.cpp b/VulkanLearn2/Scene/MaterialManager.cpp
new file mode 100644
index 0000000..7b7ef80
--- /dev/null
+++ b/VulkanLearn2/Scene/MaterialManager.cpp
@@ -0,0 +1,101 @@
+#include "pch.h"
+#include "MaterialManager.h"
+
+#include "Core\VulkanCommandManager.h"
+#include "TextureManager.h"
+#include "Core\VulkanDescriptor.h"
+
+
+MaterialManager::MaterialManager(const VulkanHandles& vulkanHandles, VulkanCommandManager* commandManager, TextureManager* textureManager):
+	m_VulkanHandles(vulkanHandles),
+	m_CommandManager(commandManager),
+	m_TextureManager(textureManager)
+{
+
+}
+
+MaterialManager::~MaterialManager()
+{
+	delete(m_MaterialBuffer);
+}
+
+uint32_t MaterialManager::LoadMaterial(const MaterialRawData& materialRawData)
+{
+	MaterialData material{};
+	if (materialRawData.diffuseMapFileName != "")
+	{
+		material.diffuseMapIndex = m_TextureManager->LoadTextureImage(materialRawData.diffuseMapFileName);
+	}
+	if (materialRawData.normalMapFileName != "")
+	{
+		material.normalMapIndex = m_TextureManager->LoadTextureImage(materialRawData.normalMapFileName);
+	}
+	if (materialRawData.specularMapFileName != "")
+	{
+		material.specularMapIndex = m_TextureManager->LoadTextureImage(materialRawData.specularMapFileName);
+	}
+
+	m_Handles.allMaterials.push_back(material);
+	return m_Handles.allMaterials.size() - 1;
+}
+
+VulkanDescriptor* MaterialManager::GetDescriptor()
+{
+	return m_Handles.descriptor;
+}
+
+void MaterialManager::Finalize()
+{
+	CreateMaterialBuffer();
+	CreateMaterialDescriptor();
+}
+
+void MaterialManager::CreateMaterialBuffer()
+{
+	VkDeviceSize bufferSize = sizeof(MaterialData) * m_Handles.allMaterials.size();
+
+	if (bufferSize == 0)
+	{
+		return;
+	}
+
+	VkBufferCreateInfo bufferInfo{};
+	bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
+	bufferInfo.queueFamilyIndexCount = 1;
+	bufferInfo.pQueueFamilyIndices = &m_VulkanHandles.queueFamilyIndices.GraphicQueueIndex;
+	bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
+	bufferInfo.size = bufferSize;
+	bufferInfo.usage = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
+
+	m_MaterialBuffer = new VulkanBuffer(m_VulkanHandles, m_CommandManager, bufferInfo, VMA_MEMORY_USAGE_GPU_ONLY);
+
+	m_MaterialBuffer->UploadData(m_Handles.allMaterials.data(), bufferSize, 0);
+}
+
+void MaterialManager::CreateMaterialDescriptor()
+{
+	if (m_Handles.allMaterials.size() == 0)
+	{
+		return;
+	}
+
+	VkDescriptorBufferInfo bufferInfo{};
+	bufferInfo.buffer = m_MaterialBuffer->GetHandles().buffer;
+	bufferInfo.offset = 0;
+	bufferInfo.range = m_MaterialBuffer->GetHandles().bufferSize;
+
+	BufferDescriptorUpdateInfo bufferUpdateInfo{};
+	bufferUpdateInfo.binding = 0;
+	bufferUpdateInfo.firstArrayElement = 0;
+	bufferUpdateInfo.bufferInfos = { bufferInfo };
+
+	BindingElementInfo bindingElementInfo{};  
+	bindingElementInfo.binding = 0;
+	bindingElementInfo.descriptorCount = 1;
+	bindingElementInfo.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
+	bindingElementInfo.bufferDescriptorUpdateInfoCount = 1;
+	bindingElementInfo.pBufferDescriptorUpdates = &bufferUpdateInfo;
+	bindingElementInfo.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;
+
+	m_Handles.descriptor = new VulkanDescriptor(m_VulkanHandles, { bindingElementInfo }, 2);
+}
diff --git a/VulkanLearn2/Scene/MaterialManager.h b/VulkanLearn2/Scene/MaterialManager.h
new file mode 100644
index 0000000..b1ca856
--- /dev/null
+++ b/VulkanLearn2/Scene/MaterialManager.h
@@ -0,0 +1,57 @@
+﻿#pragma once
+#include "Core\VulkanContext.h"
+#include "Core\VulkanBuffer.h"
+
+class VulkanCommandManager;
+class TextureManager;
+class VulkanDescriptor;
+
+
+struct MaterialData
+{
+	// Index trỏ vào mảng texture (TextureManager)
+	alignas(4) uint32_t diffuseMapIndex;
+	alignas(4) uint32_t normalMapIndex;
+	alignas(4) uint32_t specularMapIndex;
+
+	alignas(4) uint32_t _padding;
+};
+
+struct MaterialRawData
+{
+	std::string diffuseMapFileName = "";
+	std::string normalMapFileName = "";
+	std::string specularMapFileName = "";
+};
+
+struct MaterialManagerHandles
+{
+	std::vector<MaterialData> allMaterials;
+	VulkanDescriptor* descriptor;
+};
+
+class MaterialManager
+{
+public:
+	MaterialManager(const VulkanHandles& vulkanHandles, VulkanCommandManager* commandManager, TextureManager* textureManager);
+	~MaterialManager();
+
+	const MaterialManagerHandles& GetHandles() const { return m_Handles; }
+
+	uint32_t LoadMaterial(const MaterialRawData& materialRawData);
+
+
+	VulkanDescriptor* GetDescriptor();
+	void Finalize();
+private:
+	const VulkanHandles& m_VulkanHandles;
+	VulkanCommandManager* m_CommandManager;
+	TextureManager* m_TextureManager;
+
+	MaterialManagerHandles m_Handles;
+
+	VulkanBuffer* m_MaterialBuffer;
+	
+	void CreateMaterialBuffer();
+	void CreateMaterialDescriptor();
+};
diff --git a/VulkanLearn2/Scene/Model.cpp b/VulkanLearn2/Scene/Model.cpp
index 8de112a..460dfe3 100644
--- a/VulkanLearn2/Scene/Model.cpp
+++ b/VulkanLearn2/Scene/Model.cpp
@@ -2,27 +2,13 @@
 #include "Model.h"
 #include "MeshManager.h"
 #include "Utils/ModelLoader.h"
-#include "TextureManager.h"
+#include "MaterialManager.h"
 
-Model::Model(const std::string& modelFilePath, MeshManager* meshManager, TextureManager* textureManager)
+Model::Model(const std::string& modelFilePath, MeshManager* meshManager, MaterialManager* materialManager)
 {
-	// 1. Dùng ModelLoader để tải dữ liệu thô (vertex, index, texture path) từ file model.
-	ModelLoader modelLoader;
-	ModelData modelData = modelLoader.LoadModelFromFile(modelFilePath);
-
-	// 2. Dùng MeshManager để tạo các đối tượng Mesh từ dữ liệu thô.
-	//    Hàm này sẽ đưa dữ liệu vertex/index vào các buffer chung và trả về các struct Mesh
-	//    chứa thông tin về vị trí và kích thước của dữ liệu đó trong buffer.
-	m_Handles.meshes = meshManager->createMeshFromMeshData(modelData.meshData.data(),static_cast<uint32_t>(modelData.meshData.size()));
-
-	// 3. Với mỗi mesh, tải texture tương ứng thông qua TextureManager.
-	for (int i = 0; i < m_Handles.meshes.size(); i++)
-	{
-		// Lấy ID của texture và gán vào mesh.
-		// LƯU Ý: Đường dẫn texture đang được ghép nối cứng với prefix "Resources/Textures/".
-		// Điều này có thể cần được cấu hình linh hoạt hơn trong tương lai.
-		m_Handles.meshes[i]->textureId = textureManager->LoadTextureImage("Resources/Textures/" + modelData.meshData[i].textureFilePath);
-	}
+	// ModelLoader giờ đây sẽ nhận các manager và trực tiếp xử lý việc tạo Mesh và Material.
+	ModelLoader modelLoader(meshManager, materialManager);
+	m_Handles.meshes = modelLoader.LoadModelFromFile(modelFilePath);
 }
 
 Model::~Model()
diff --git a/VulkanLearn2/Scene/Model.h b/VulkanLearn2/Scene/Model.h
index f6eb65e..1cad30c 100644
--- a/VulkanLearn2/Scene/Model.h
+++ b/VulkanLearn2/Scene/Model.h
@@ -24,7 +24,7 @@ struct MeshRange
 struct Mesh
 {
 	MeshRange meshRange;
-	uint32_t textureId;
+	uint32_t materialIndex;
 };
 
 // Struct chứa dữ liệu nội bộ của một Model.
@@ -33,14 +33,16 @@ struct ModelHandles
 	std::vector<Mesh*> meshes;
 };
 
+class MaterialManager;
+
 // Class Model đại diện cho một đối tượng 3D có thể render, bao gồm một hoặc nhiều mesh.
-// Class này chịu trách nhiệm điều phối việc tải dữ liệu model từ file
+// Class này chịu trách nhiệm điều phối việc điều phối việc tải dữ liệu model từ file
 // và tạo ra các đối tượng Mesh tương ứng.
 class Model
 {
 public:
 	// Constructor tải model từ file và tạo các mesh thông qua các manager.
-	Model(const std::string& modelFilePath, MeshManager* meshManager, TextureManager* textureManager);
+	Model(const std::string& modelFilePath, MeshManager* meshManager, MaterialManager* materialManager);
 	
 	// Destructor, chịu trách nhiệm giải phóng các đối tượng Mesh mà nó sở hữu.
 	~Model();
diff --git a/VulkanLearn2/Scene/RenderObject.cpp b/VulkanLearn2/Scene/RenderObject.cpp
index fb4bfff..1275ea9 100644
--- a/VulkanLearn2/Scene/RenderObject.cpp
+++ b/VulkanLearn2/Scene/RenderObject.cpp
@@ -1,12 +1,12 @@
 #include "pch.h"
 #include "RenderObject.h"
 #include "Model.h"
-#include "TextureManager.h"
+#include "MaterialManager.h"
 
-RenderObject::RenderObject(const std::string& modelFilePath, MeshManager* meshManager, TextureManager* textureManager)
+RenderObject::RenderObject(const std::string& modelFilePath, MeshManager* meshManager, MaterialManager* materialManager)
 {
 	// RenderObject sở hữu một đối tượng Model, được tạo ra khi RenderObject được tạo.
-	m_Handles.model = new Model(modelFilePath, meshManager, textureManager);
+	m_Handles.model = new Model(modelFilePath, meshManager, materialManager);
 }
 
 RenderObject::~RenderObject()
diff --git a/VulkanLearn2/Scene/RenderObject.h b/VulkanLearn2/Scene/RenderObject.h
index a1fdf9b..5b80cfb 100644
--- a/VulkanLearn2/Scene/RenderObject.h
+++ b/VulkanLearn2/Scene/RenderObject.h
@@ -25,12 +25,13 @@ struct RenderObjectHandles
 	Model* model = nullptr;
 };
 
+class MaterialManager;
+
 // Class đại diện cho một đối tượng có thể được vẽ trong scene.
-// Nó bao gồm một Model (dữ liệu hình học) và một Transform (vị trí trong không gian).
 class RenderObject
 {
 public:
-	RenderObject(const std::string& modelFilePath, MeshManager* meshManager, TextureManager* textureManager);
+	RenderObject(const std::string& modelFilePath, MeshManager* meshManager, MaterialManager* materialManager);
 	~RenderObject();
 
 	// --- Thao tác với Transform ---
diff --git a/VulkanLearn2/Shaders/RTT_Shader.frag b/VulkanLearn2/Shaders/RTT_Shader.frag
index b68fd1a..1a6fe31 100644
--- a/VulkanLearn2/Shaders/RTT_Shader.frag
+++ b/VulkanLearn2/Shaders/RTT_Shader.frag
@@ -1,12 +1,27 @@
 #version 450
 
 layout(location = 0) in vec2 fragTexCoord;
-layout(location = 1) flat in uint textureId;
+layout(location = 1) flat in uint fragMaterialId;
 
 layout(location = 0) out vec4 outColor;
 
 layout(set = 0, binding = 0) uniform sampler2D texSampler[256];
 
+struct MaterialData {
+    uint diffuseMapIndex;
+    uint normalMapIndex;
+    uint specularMapIndex;
+    uint padding;
+};
+
+layout(set = 2, binding = 0) readonly buffer Materials {
+    MaterialData materials[];
+} materialsBuffer;
+
 void main() {
-    outColor = texture(texSampler[textureId], fragTexCoord);
-}
+    MaterialData material = materialsBuffer.materials[fragMaterialId];
+    
+    uint diffuseTextureIndex = material.diffuseMapIndex;
+    
+    outColor = texture(texSampler[diffuseTextureIndex], fragTexCoord);
+}
\ No newline at end of file
diff --git a/VulkanLearn2/Shaders/RTT_Shader.vert b/VulkanLearn2/Shaders/RTT_Shader.vert
index d934354..85d93be 100644
--- a/VulkanLearn2/Shaders/RTT_Shader.vert
+++ b/VulkanLearn2/Shaders/RTT_Shader.vert
@@ -1,11 +1,11 @@
 #version 450
 
 layout(location = 0) in vec3 inPosition;
-layout(location = 1) in vec3 color;
+layout(location = 1) in vec3 inNormal;
 layout(location = 2) in vec2 inTexCoord;
 
 layout(location = 0) out vec2 fragTexCoord;
-layout(location = 1) flat out uint textureId;
+layout(location = 1) flat out uint fragMaterialId;
 
 layout(set = 1, binding = 0) uniform UniformBufferObject {
     mat4 view;
@@ -14,11 +14,11 @@ layout(set = 1, binding = 0) uniform UniformBufferObject {
 
 layout(push_constant) uniform PushConstantData {
     mat4 model;
-    uint textureId;
+    uint materialId;
 } pc;
 
 void main() {
     gl_Position = ubo.proj * ubo.view * pc.model * vec4(inPosition, 1.0);
     fragTexCoord = inTexCoord;
-    textureId = pc.textureId;
-}
+    fragMaterialId = pc.materialId;
+}
\ No newline at end of file
diff --git a/VulkanLearn2/Utils/ModelLoader.cpp b/VulkanLearn2/Utils/ModelLoader.cpp
index cff871c..944bf57 100644
--- a/VulkanLearn2/Utils/ModelLoader.cpp
+++ b/VulkanLearn2/Utils/ModelLoader.cpp
@@ -1,146 +1,146 @@
 #include "pch.h"
 #include "ModelLoader.h"
 #include "Core/VulkanContext.h" // Include để có định nghĩa đầy đủ của struct Vertex
+#include "Scene/MeshManager.h"
+#include "Scene/Model.h"
 #include <stdexcept>
 
-// --- Các hàm helper xử lý dữ liệu Assimp --- 
-// Được đặt trong anonymous namespace để giới hạn phạm vi truy cập chỉ trong file này.
-namespace {
-
-	// Duyệt qua cây node của scene Assimp một cách đệ quy.
-	void ProcessNode(aiNode* node, const aiScene* scene, ModelData& modelData);
-
-	// Xử lý một mesh đơn lẻ trong scene Assimp để trích xuất dữ liệu.
-	MeshData ProcessMesh(aiMesh* mesh, const aiScene* scene);
-
-	// Tiện ích để lấy tên file từ một đường dẫn đầy đủ.
-	std::string GetFileNameFromPath(const std::string& fullPath);
-
-} // anonymous namespace
-
-
-// --- Triển khai các hàm của ModelLoader ---
+ModelLoader::ModelLoader(MeshManager* meshManager, MaterialManager* materialManager)
+	: m_MeshManager(meshManager), m_MaterialManager(materialManager)
+{
+}
 
-ModelData ModelLoader::LoadModelFromFile(const std::string& filePath)
+std::vector<Mesh*> ModelLoader::LoadModelFromFile(const std::string& filePath)
 {
-	ModelData modelData;
+	std::vector<Mesh*> meshes;
 	Assimp::Importer importer;
 
 	// Các cờ xử lý hậu kỳ của Assimp.
-	// Yêu cầu Assimp thực hiện các bước chuẩn hóa dữ liệu sau khi tải.
-	unsigned int flags = 
+	unsigned int flags =
 		aiProcess_Triangulate |
 		aiProcess_JoinIdenticalVertices |
 		aiProcess_GenSmoothNormals |
-		//aiProcess_FlipUVs |
 		aiProcess_CalcTangentSpace;
 
-	// LƯU Ý: Đoạn code này kiểm tra nếu file là .assbin (định dạng nhị phân của Assimp)
-	// thì sẽ bỏ qua tất cả các cờ xử lý hậu kỳ. Điều này giả định rằng file .assbin
-	// đã được xử lý trước đó.
 	if (filePath.size() > 7 && filePath.substr(filePath.size() - 7) == ".assbin")
 	{
 		flags = 0;
 	}
 
-	// Đọc file model.
 	const aiScene* scene = importer.ReadFile(filePath, flags);
 
-	// Kiểm tra lỗi.
 	if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode)
 	{
 		throw std::runtime_error("LỖI ASSIMP: " + std::string(importer.GetErrorString()));
 	}
 
-	// Bắt đầu xử lý từ node gốc của scene.
-	ProcessNode(scene->mRootNode, scene, modelData);
+	ProcessNode(scene->mRootNode, scene, meshes);
 
-	return modelData;
+	return meshes;
 }
 
+void ModelLoader::ProcessNode(aiNode* node, const aiScene* scene, std::vector<Mesh*>& outMeshes)
+{
+	// Xử lý tất cả các mesh trong node hiện tại.
+	for (unsigned int i = 0; i < node->mNumMeshes; i++)
+	{
+		aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
+		outMeshes.push_back(ProcessMesh(mesh, scene));
+	}
 
-// --- Định nghĩa các hàm helper trong anonymous namespace ---
-namespace {
+	// Duyệt đệ quy qua tất cả các node con.
+	for (unsigned int i = 0; i < node->mNumChildren; i++)
+	{
+		ProcessNode(node->mChildren[i], scene, outMeshes);
+	}
+}
+
+Mesh* ModelLoader::ProcessMesh(aiMesh* mesh, const aiScene* scene)
+{
+	MeshData currentMeshData;
 
-	void ProcessNode(aiNode* node, const aiScene* scene, ModelData& modelData)
+	// Trích xuất dữ liệu đỉnh (vị trí, pháp tuyến, UV).
+	for (unsigned int i = 0; i < mesh->mNumVertices; i++)
 	{
-		// Xử lý tất cả các mesh trong node hiện tại.
-		for (unsigned int i = 0; i < node->mNumMeshes; i++)
+		Vertex vertex;
+		vertex.pos = { mesh->mVertices[i].x, mesh->mVertices[i].y, mesh->mVertices[i].z };
+		if (mesh->HasNormals())
 		{
-			aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
-			modelData.meshData.push_back(ProcessMesh(mesh, scene));
+			vertex.normal = { mesh->mNormals[i].x, mesh->mNormals[i].y, mesh->mNormals[i].z };
 		}
-
-		// Duyệt đệ quy qua tất cả các node con.
-		for (unsigned int i = 0; i < node->mNumChildren; i++)
+		if (mesh->mTextureCoords[0])
 		{
-			ProcessNode(node->mChildren[i], scene, modelData);
+			vertex.uv = { mesh->mTextureCoords[0][i].x, mesh->mTextureCoords[0][i].y };
 		}
+		currentMeshData.vertices.push_back(vertex);
 	}
 
-	MeshData ProcessMesh(aiMesh* mesh, const aiScene* scene)
+	// Trích xuất dữ liệu chỉ số (index).
+	for (unsigned int i = 0; i < mesh->mNumFaces; i++)
 	{
-		MeshData currentMeshData;
-
-		// Trích xuất dữ liệu đỉnh (vị trí, pháp tuyến, UV).
-		for (unsigned int i = 0; i < mesh->mNumVertices; i++)
+		aiFace face = mesh->mFaces[i];
+		for (unsigned int j = 0; j < face.mNumIndices; j++)
 		{
-			Vertex vertex;
-
-			vertex.pos = { mesh->mVertices[i].x, mesh->mVertices[i].y, mesh->mVertices[i].z };
+			currentMeshData.indices.push_back(face.mIndices[j]);
+		}
+	}
 
-			if (mesh->HasNormals())
-			{
-				vertex.normal = { mesh->mNormals[i].x, mesh->mNormals[i].y, mesh->mNormals[i].z };
-			}
+	// 1. Dùng MeshManager để tạo đối tượng Mesh từ MeshData.
+	//    Hàm này sẽ gộp vertex/index data vào buffer chung và trả về một Mesh*
+	//    với thông tin MeshRange đã được điền.
+	std::vector<Mesh*> createdMeshes = m_MeshManager->createMeshFromMeshData(&currentMeshData, 1);
+	Mesh* newMesh = createdMeshes[0];
 
-			// Assimp hỗ trợ nhiều bộ UV, ở đây ta chỉ lấy bộ đầu tiên (kênh 0).
-			if (mesh->mTextureCoords[0])
+	// 2. Trích xuất thông tin material từ Assimp.
+	aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
+	MaterialRawData materialRawData;
+	if (material)
+	{
+		aiString texPath;
+		if (material->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS)
+		{
+			std::string fileName = GetFileNameFromPath(texPath.C_Str());
+			if (!fileName.empty())
 			{
-				vertex.uv = { mesh->mTextureCoords[0][i].x, mesh->mTextureCoords[0][i].y };
+				materialRawData.diffuseMapFileName = TEXTURE_PATH_PREFIX + fileName;
 			}
-
-			currentMeshData.vertices.push_back(vertex);
 		}
-
-		// Trích xuất dữ liệu chỉ số (index).
-		for (unsigned int i = 0; i < mesh->mNumFaces; i++)
+		if (material->GetTexture(aiTextureType_NORMALS, 0, &texPath) == AI_SUCCESS)
 		{
-			aiFace face = mesh->mFaces[i];
-			for (unsigned int j = 0; j < face.mNumIndices; j++)
+			std::string fileName = GetFileNameFromPath(texPath.C_Str());
+			if (!fileName.empty())
 			{
-				currentMeshData.indices.push_back(face.mIndices[j]);
+				materialRawData.normalMapFileName = TEXTURE_PATH_PREFIX + fileName;
 			}
 		}
-
-		// Trích xuất đường dẫn file texture từ material.
-		aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
-		if (material)
+		if (material->GetTexture(aiTextureType_SPECULAR, 0, &texPath) == AI_SUCCESS)
 		{
-			aiString texPath;
-			// Chỉ lấy texture khuếch tán (diffuse) đầu tiên.
-			if (material->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS)
+			std::string fileName = GetFileNameFromPath(texPath.C_Str());
+			if (!fileName.empty())
 			{
-				currentMeshData.textureFilePath = GetFileNameFromPath(texPath.C_Str());
+				materialRawData.specularMapFileName = TEXTURE_PATH_PREFIX + fileName;
 			}
 		}
-
-		return currentMeshData;
 	}
 
-	std::string GetFileNameFromPath(const std::string& fullPath)
-	{
-		// Tìm vị trí dấu gạch chéo cuối cùng.
-		size_t lastSlash = fullPath.find_last_of("/\\");
+	// 3. Dùng MaterialManager để load material và lấy về index.
+	uint32_t materialIndex = m_MaterialManager->LoadMaterial(materialRawData);
+	
+	// 4. Gán material index cho Mesh vừa tạo.
+	newMesh->materialIndex = materialIndex;
 
-		if (lastSlash == std::string::npos)
-		{
-			return fullPath; // Không có dấu gạch chéo, trả về toàn bộ chuỗi.
-		}
-		else
-		{
-			return fullPath.substr(lastSlash + 1); // Trả về chuỗi con sau dấu gạch chéo.
-		}
-	}
+	return newMesh;
+}
 
-} // anonymous namespace
\ No newline at end of file
+std::string ModelLoader::GetFileNameFromPath(const std::string& fullPath)
+{
+	size_t lastSlash = fullPath.find_last_of("/\\");
+	if (lastSlash == std::string::npos)
+	{
+		return fullPath;
+	}
+	else
+	{
+		return fullPath.substr(lastSlash + 1);
+	}
+}
diff --git a/VulkanLearn2/Utils/ModelLoader.h b/VulkanLearn2/Utils/ModelLoader.h
index 2190729..fd3aa04 100644
--- a/VulkanLearn2/Utils/ModelLoader.h
+++ b/VulkanLearn2/Utils/ModelLoader.h
@@ -3,43 +3,49 @@
 #include <string>
 #include <vector>
 
-// LƯU Ý: Các include của Assimp được đặt ở đây để file .cpp có thể sử dụng,
-// nhưng chúng làm cho header này phụ thuộc vào thư viện Assimp.
-// Một thiết kế tốt hơn có thể là dùng forward declaration cho các kiểu của Assimp
-// và chỉ include trong file .cpp (PIMPL idiom).
 #include <assimp/Importer.hpp>
 #include <assimp/scene.h>
 #include <assimp/postprocess.h>
+#include "Scene/MaterialManager.h"
 
-// Forward-declare struct Vertex để tránh include file VulkanContext.h không cần thiết.
+// Forward declarations
 struct Vertex;
+struct Mesh;
+class MeshManager;
+class MaterialManager;
 
 // Struct chứa dữ liệu thô của một mesh (đỉnh, chỉ số, và đường dẫn texture).
 struct MeshData
 {
 	std::vector<Vertex> vertices;
 	std::vector<uint32_t> indices;
-	std::string textureFilePath;
-};
-
-// Struct chứa dữ liệu của toàn bộ model, bao gồm một hoặc nhiều MeshData.
-struct ModelData
-{
-	std::vector<MeshData> meshData;
+	MaterialRawData materialRawData;
 };
 
 // Class tiện ích để tải dữ liệu model từ file bằng thư viện Assimp.
-// Class này không có trạng thái, hoạt động như một namespace chứa hàm.
 class ModelLoader
 {
 public:
-	ModelLoader() = default;
+	ModelLoader(MeshManager* meshManager, MaterialManager* materialManager);
 	~ModelLoader() = default;
 
 	// Hàm chính để tải model từ file.
-	// Trả về một struct ModelData chứa tất cả dữ liệu đã được xử lý.
-	ModelData LoadModelFromFile(const std::string& filePath);
+	// Trả về một vector các con trỏ tới Mesh đã được tạo và quản lý bởi MeshManager.
+	std::vector<Mesh*> LoadModelFromFile(const std::string& filePath);
 
 private:
-	// Class này không có biến thành viên.
-};
+	MeshManager* m_MeshManager;
+	MaterialManager* m_MaterialManager;
+
+	// Duyệt qua cây node của scene Assimp một cách đệ quy.
+	void ProcessNode(aiNode* node, const aiScene* scene, std::vector<Mesh*>& outMeshes);
+	
+	// Xử lý một mesh đơn lẻ trong scene Assimp để trích xuất dữ liệu,
+	// tạo Mesh và Material, và trả về con trỏ tới Mesh đã tạo.
+	Mesh* ProcessMesh(aiMesh* mesh, const aiScene* scene);
+
+	// Tiện ích để lấy tên file từ một đường dẫn đầy đủ.
+	std::string GetFileNameFromPath(const std::string& fullPath);
+
+	const std::string TEXTURE_PATH_PREFIX = "Resources/Textures/";
+};
\ No newline at end of file
diff --git a/VulkanLearn2/VulkanLearn2.vcxproj b/VulkanLearn2/VulkanLearn2.vcxproj
index 6c063e3..6b93321 100644
--- a/VulkanLearn2/VulkanLearn2.vcxproj
+++ b/VulkanLearn2/VulkanLearn2.vcxproj
@@ -39,6 +39,7 @@
     <ClCompile Include="Renderer\BrightFilterPass.cpp" />
     <ClCompile Include="Renderer\CompositePass.cpp" />
     <ClCompile Include="Renderer\GeometryPass.cpp" />
+    <ClCompile Include="Scene\MaterialManager.cpp" />
     <ClCompile Include="Scene\MeshManager.cpp" />
     <ClCompile Include="Scene\Model.cpp" />
     <ClCompile Include="Scene\RenderObject.cpp" />
@@ -73,6 +74,7 @@
     <ClInclude Include="Renderer\CompositePass.h" />
     <ClInclude Include="Renderer\GeometryPass.h" />
     <ClInclude Include="Renderer\IRenderPass.h" />
+    <ClInclude Include="Scene\MaterialManager.h" />
     <ClInclude Include="Scene\MeshManager.h" />
     <ClInclude Include="Scene\Model.h" />
     <ClInclude Include="Scene\RenderObject.h" />
diff --git a/VulkanLearn2/VulkanLearn2.vcxproj.filters b/VulkanLearn2/VulkanLearn2.vcxproj.filters
index 755fdd7..2e1685a 100644
--- a/VulkanLearn2/VulkanLearn2.vcxproj.filters
+++ b/VulkanLearn2/VulkanLearn2.vcxproj.filters
@@ -114,6 +114,9 @@
     <ClCompile Include="Renderer\GeometryPass.cpp">
       <Filter>Source Files\Renderer</Filter>
     </ClCompile>
+    <ClCompile Include="Scene\MaterialManager.cpp">
+      <Filter>Source Files\Scene</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Core\Window.h">
@@ -194,6 +197,9 @@
     <ClInclude Include="Renderer\GeometryPass.h">
       <Filter>Header Files\Renderer</Filter>
     </ClInclude>
+    <ClInclude Include="Scene\MaterialManager.h">
+      <Filter>Header Files\Scene</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <None Include="Shaders\compile.bat">
diff --git a/VulkanLearn2/main.cpp b/VulkanLearn2/main.cpp
index 0dc9cfe..18b2a19 100644
--- a/VulkanLearn2/main.cpp
+++ b/VulkanLearn2/main.cpp
@@ -22,6 +22,7 @@
 #include "Scene/MeshManager.h"
 #include "Scene/Model.h"
 #include "Scene/TextureManager.h"
+#include "Scene/MaterialManager.h"
 
 
 // =================================================================================================
@@ -74,15 +75,18 @@ Application::Application()
 	// Khởi tạo các manager và tải các model, texture từ file.
 	m_MeshManager = new MeshManager(m_VulkanContext->getVulkanHandles(), m_VulkanCommandManager);
 	m_TextureManager = new TextureManager(m_VulkanContext->getVulkanHandles(), m_VulkanCommandManager, m_VulkanSampler->getSampler());
+	m_MaterialManager = new MaterialManager(m_VulkanContext->getVulkanHandles(), m_VulkanCommandManager, m_TextureManager);
 
-	m_BunnyGirl = new RenderObject("Resources/bunnyGirl.assbin", m_MeshManager, m_TextureManager);
-	m_Swimsuit = new RenderObject("Resources/swimSuit.assbin", m_MeshManager, m_TextureManager);
+	m_BunnyGirl = new RenderObject("Resources/bunnyGirl.assbin", m_MeshManager, m_MaterialManager);
+	m_Swimsuit = new RenderObject("Resources/swimSuit.assbin", m_MeshManager, m_MaterialManager);
 	m_BunnyGirl->SetRotation({ -90, 0, 0 });
 
 	m_RenderObjects.push_back(m_BunnyGirl);
 	m_RenderObjects.push_back(m_Swimsuit);
+	
 
 	// Hoàn tất việc tải texture: upload dữ liệu ảnh lên GPU và tạo descriptor set cho texture.
+	m_MaterialManager->Finalize();
 	m_TextureManager->FinalizeSetup();
 
 	// --- 5. TẠO CÁC RENDER PASS ---
@@ -105,6 +109,7 @@ Application::Application()
 	// --- 7. TẢI DỮ LIỆU LÊN GPU ---
 	// Sau khi tất cả các mesh đã được xử lý, tạo và tải dữ liệu vào vertex/index buffer trên GPU.
 	m_MeshManager->CreateBuffers();
+
 }
 
 /**
@@ -131,6 +136,7 @@ Application::~Application()
 	delete(m_VulkanCommandManager);
 	delete(m_MeshManager);
 	delete(m_TextureManager);
+	delete(m_MaterialManager);
 
 	// 3. Giải phóng Buffers (ví dụ: uniform buffers).
 	for (auto& uniformBuffer : m_RTT_UniformBuffers)
@@ -474,6 +480,7 @@ void Application::CreateRenderPasses()
 	GeometryPassCreateInfo geometryInfo{};
 	geometryInfo.textureManager = m_TextureManager;
 	geometryInfo.meshManager = m_MeshManager;
+	geometryInfo.materialManager = m_MaterialManager;
 	geometryInfo.colorImages = &m_RTT_ColorImage;
 	geometryInfo.depthStencilImages = &m_RTT_DepthStencilImage;
 	geometryInfo.outputImage = &m_SceneImages;
diff --git a/VulkanLearn2/main.h b/VulkanLearn2/main.h
index 1759a29..9f60373 100644
--- a/VulkanLearn2/main.h
+++ b/VulkanLearn2/main.h
@@ -6,6 +6,7 @@
 // Structs
 struct UniformBufferObject;
 struct PushConstantData;
+class MaterialManager;
 
 // Classes
 class Window;
@@ -81,6 +82,7 @@ private:
 	VulkanDescriptorManager* m_VulkanDescriptorManager;
 	MeshManager* m_MeshManager;
 	TextureManager* m_TextureManager;
+	MaterialManager* m_MaterialManager;
 
 	// =================================================================================================
 	// SECTION: TÀI NGUYÊN RENDER (FRAMEBUFFER ATTACHMENTS)
